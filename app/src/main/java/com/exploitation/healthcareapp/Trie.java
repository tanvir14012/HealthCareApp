package com.exploitation.healthcareapp;

import android.content.Context;
import android.util.Log;

import java.util.BitSet;
import java.util.StringTokenizer;

/**
 * Created by TANVIR on 1/28/2018.
 */

class Trie {
    private Node root;
    private  int catagoryId;
    private Context context;
    public Trie(int catagoryId, Context context) {
        root = new Node(false,-1);
        this.catagoryId = catagoryId;
        this.context = context;
    }
    public void load() {
        StringTokenizer st = null;
        String str = null;
        String symbol = ListTipsCatagory.getCatagorySymbol(catagoryId)+"N";
        for(int i = 0; i<ListTipsCatagory.getNoOfTips(catagoryId); i++) {
            str = context.getString( context.getResources().getIdentifier(symbol+i, "string", context.getPackageName()) );

            st = new StringTokenizer(str.toLowerCase(), " ");
            while(st.hasMoreElements()) {
                insert(st.nextToken(), i);
                //Log.d("tokens", st.nextToken()+"!!");
            }
        }
    }
    public void insert(String word, int tipsNo) {
        int i,j,index;
        i = j = 0;
        Node node = root;
        while(i<word.length() && node.child[word.charAt(i)-'a'] != null) {
            index = word.charAt(i) - 'a';
            j = 0;
            StringBuilder label = node.edge[index];
            while(i<word.length() && j<label.length()
                    && word.charAt(i) == label.charAt(j))
            {
                i++;
                j++;
            }
            if(j == label.length()) {//word length > current edge/label
                node = node.child[index];
            }
            else {
                if(i == word.length()) {//word is a prefix of edge/label
                    Node currChild = node.child[index];
                    Node newChild = new Node(true,tipsNo);
                    StringBuilder remainingLabel = cutItFromI(node.edge[index], j);
                    label.setLength(j);//cutting off the remainingLabel
                    //Linking
                    node.child[index] = newChild;
                    newChild.child[remainingLabel.charAt(0)-'a'] = currChild;
                    newChild.edge[remainingLabel.charAt(0)-'a'] = remainingLabel;
                }
                else {//word is partially matched with edge/label eg. facebook(edge) & facepalm(word).
                    Node currChild = node.child[index];
                    Node newChild = new Node(false,-1);
                    StringBuilder remainingLabel = cutItFromI(node.edge[index], j);
                    StringBuilder remainingWord = cutItFromI(word,i);
                    label.setLength(j);//cutting off the remainingLabel
                    //Linking
                    node.child[index] = newChild;
                    newChild.edge[remainingLabel.charAt(0)-'a'] = remainingLabel;
                    newChild.edge[remainingWord.charAt(0)-'a'] = remainingWord;
                    newChild.child[remainingLabel.charAt(0)-'a'] = currChild;
                    newChild.child[remainingWord.charAt(0)-'a']= new Node(true,tipsNo);
                }
                return ;
            }
        }
        if(i < word.length()) { //Case : 1. Think trie has "ab" & insert "abcd".It will go through 'if(j==label.length()'.
            node.edge[word.charAt(i) - 'a'] = cutItFromI(word, i);
            node.child[word.charAt(i) - 'a'] = new Node(true, tipsNo);
        }
        else {// i==word.length, eg. insert "there"(word) and "thereafter("edge/label)
            node.isEnd = true;
            if(node.bitset == null) {
                node.initializeBitset();
            }
            node.bitset.set(tipsNo);
        }
    }
    public BitSet search(String word) {
        BitSet res = null;
        if(word.equals("")){
            return res;
        }
        int i,j,index;
        i = j = 0;
        Node node = root;
        while(i<word.length() && node.child[word.charAt(i)-'a'] != null) {
            index = word.charAt(i) - 'a';
            j = 0;
            StringBuilder label = node.edge[index];
            while(i<word.length() && j<label.length()){
                if(word.charAt(i) != label.charAt(j)){
                    return res;
                }
                i++; j++;
            }
            if(j == label.length() && i<= word.length()) {
                node = node.child[index];
            }
            else { // i>word.length(), meaning word length<label
                return res;
            }
        }
        if (i==word.length() && node.isEnd) {
            return node.bitset;
        }else {
            return res;
        }
    }
    private StringBuilder cutItFromI(CharSequence word, int i) {
        StringBuilder result = new StringBuilder(50);
        while(i != word.length()) {
            result.append(word.charAt(i));
            i++;
        }
        return result;
    }
    private class Node {
        private static final int ALPHABET = 26;
        private boolean isEnd;
        private Node[] child;
        private StringBuilder[] edge;
        private BitSet bitset  = null;
        private Node(boolean end, int tipsNo){
            this.isEnd = end;
            child = new Node[ALPHABET];
            edge = new StringBuilder[ALPHABET];
            if(end == true) {
                if(this.bitset == null){
                    this.initializeBitset();
                }
                this.bitset.set(tipsNo);
            }
        }
        private void initializeBitset() {
            this.bitset = new BitSet(100);
        }
    }


}